from shapely.geometry import Point
from shapely.geometry.polygon import Polygon
import csv
import numpy as np
import json
import sys
import os

# -- Retrieve arguments
scenario = sys.argv[1]
horizon = sys.argv[2]

# -- Json output filename
outdir = '/home/jservon/Chapter12_IPCC/data/coastal_recession/'
outfilename = outdir + 'globalErosionProjections_by_AR6_region_'+scenario+'_'+horizon+'.json'

# ---------------------------------------------------------------------------------------------------
# --
# -- Retrieve the AR6 regions from the reference regions file provided by ATLAS (Santander Group)
# --
# ---------------------------------------------------------------------------------------------------
regions_filename='/home/jservon/Chapter12_IPCC/scripts/ATLAS/reference-regions/IPCC-WGI-reference-regions-v4_coordinates.csv'

# -- Store the informations by region in the 'regions' dictionary
regions = dict()
with open(regions_filename) as csvfile:
    spamreader = csv.reader(csvfile, delimiter=',')#, quotechar='|')
    for row in spamreader:
        #print(', '.join(row))
        #if row[1]=='Land':
        region_dict = dict(region = row[0],
                           domain = row[1],
                           long_name = row[2],
                          )
        lats_vect = []
        lons_vect = []
        for vertice in row[4:-1]:
            if vertice:
                dum = vertice.split('|')
                lons_vect.append(float(dum[0]))
                lats_vect.append(float(dum[1]))
        region_dict['lons_vect'] = np.array(lons_vect)
        region_dict['lats_vect'] = np.array(lats_vect)
        #
        regions[row[3]] = region_dict
        
#
# -- Function to return True if lon/lat is within region (dictionary)
def is_in_AR6_region(lon,lat,region_dict):

    lats_vect = np.array(region_dict['lats_vect'])
    lons_vect = np.array(region_dict['lons_vect'])
    lons_lats_vect = np.column_stack((lons_vect, lats_vect)) # Reshape coordinates
    polygon = Polygon(lons_lats_vect) # create polygon
    point = Point(lon,lat) # create point    
    return polygon.contains(point)

#
if not os.path.isfile(outfilename):
    # -- Build input filename
    # -----------------------------------------------------------------
    filename = '/home/ciles/IPCC/coastal/globalErosionProjections_Long_Term_Change_'+scenario+'_'+horizon+'.csv'

    # -- Retrieve coastal recession data
    # -----------------------------------------------------------------
    print 'Reading coastal recession data for ',scenario,horizon
    coastal_data = []
    with open(filename) as csvfile:
        spamreader = csv.reader(csvfile, delimiter=',')
        i = 0
        for row in spamreader:
            print i
            coastal_data.append(dict(lat=float(row[0]),
                                     lon=float(row[1]),
                                     median=float(row[5]),
                                     q5=float(row[3]),
                                     q95=float(row[7])))
            i = i + 1

    # -- Start a plot to check that the data is properly located in the regions
    # -----------------------------------------------------------------
    import matplotlib
    matplotlib.use('Agg')
    from mpl_toolkits.basemap import Basemap
    import matplotlib.pyplot as plt
    from matplotlib.patches import Polygon as Polygon_patches
    import matplotlib.colors as mcolors

    # -- Open the figure
    # -----------------------------------------------------------------
    fig = plt.figure(figsize=(12,8))
    
    # -- Prepare the map
    # -----------------------------------------------------------------
    # setup Lambert Conformal basemap.
    m = Basemap(projection='robin',lon_0=0,resolution='c')
    # draw coastlines.
    m.drawcoastlines()
    # draw a boundary around the map, fill the background.
    # this background will end up being the ocean color, since
    # the continents will be drawn on top.
    m.drawmapboundary(fill_color='white')
    # fill continents, set lake color same as ocean color.
    m.fillcontinents(color='white',lake_color='white')


    # -- Colors for the regions
    # -----------------------------------------------------------------
    tmpcolors = ['blue','green','red','brown','goldenrod','darkcyan','orange']
    mycolors = []
    for i in range(0,30):
        mycolors += tmpcolors

    # -- Function to draw the regions
    # -----------------------------------------------------------------
    def draw_screen_poly( lats, lons, m, color='red'):
        x, y = m( lons, lats )
        xy = zip(x,y)
        poly = Polygon_patches( xy, edgecolor = color, facecolor='none')
        plt.gca().add_patch(poly)

    for subregion in regions.keys():
        lons = regions[subregion]['lons_vect']
        lats = regions[subregion]['lats_vect']
        draw_screen_poly( lats, lons, m, color=mycolors[regions.keys().index(subregion)])


    # -- Attributing the points to the regions
    # -----------------------------------------------------------------
    print 'Attributing values to the regions'
    regions_values = dict()
    for subregion in regions.keys():
        regions_values[subregion] = dict(median=[], q5=[], q95=[])

    #for i in np.arange(0,500000,100):
    #    coastal_point = coastal_data[i]
    i = 0
    # -- Loop on the points
    for coastal_point in coastal_data:
        print i, '/', len(coastal_data)
        lon = coastal_point['lon']
        lat = coastal_point['lat']
        # -- Attributing the point to an AR6 region (test with is_in_AR6_region)
        for subregion in regions.keys():
            found_domain = False
            if is_in_AR6_region(lon,lat,regions[subregion]):
                found_domain = True
                regions_values[subregion]['median'].append(coastal_point['median'])
                regions_values[subregion]['q5'].append(coastal_point['q5'])
                regions_values[subregion]['q95'].append(coastal_point['q95'])
                color = mycolors[regions.keys().index(subregion)]
                break
        if not found_domain:
            color = 'black'
        x,y = m(lon, lat)
        m.plot(x, y, color, marker='o', markersize=2 )
        i = i + 1

    #plt.show()
    fig.savefig(outfilename.replace('.json','.png'))

    # -- Loop on the regions
    # -- Compute averages and put in final_res -> saved in a json file
    # -----------------------------------------------------------------
    print 'Computing averages per subregion'
    final_res = regions.copy()
    for subregion in regions:
        final_res[subregion].pop('lats_vect')
        final_res[subregion].pop('lons_vect')
        for stat in ['median','q5','q95']:
            if regions_values[subregion][stat]:
                final_res[subregion][stat] = np.mean( regions_values[subregion][stat] )

    # -- Save in json file
    # -----------------------------------------------------------------
    # -- subregion / median
    # --             q5
    # --             q95
    # --             long name
    print 'Save '+outfilename
    with open(outfilename, 'w') as fp:
        json.dump(final_res, fp, sort_keys=True, indent=4)
#
